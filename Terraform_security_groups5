terraform {
  required_providers {
    nsxt = {
      source  = "vmware/nsxt"
      version = ">=3.2.0"
    }
    local = {
      source = "hashicorp/local"
    }
  }
  required_version = ">= 0.12"
}

# Read YAML file
data "local_file" "secgroups_yaml" {
  filename = "${path.module}/input_test_file.yaml"
}

locals {
  sec_groups_data = yamldecode(data.local_file.secgroups_yaml.content)["sec_groups"]
}

resource "nsxt_policy_group" "sec_group" {
  for_each = { for sg in local.sec_groups_data : sg.display_name => sg }
  display_name = each.value.display_name

  # Build the expression block based on the type
  dynamic "expression" {
    for_each = each.value.expression
    content {
      resource_type = expression.value["resource_type"]

      # NestedExpression special logic for OR conjunction between multiple expressions
      # Assumes you want a group of NestedExpressions joined by OR at the top level
      # Additional logic needed for deeper/other conjunctions
      dynamic "expressions" {
        for_each = contains(keys(expression.value), "expressions") ? [for exp in lookup(expression.value, "expressions", []) : exp] : []
        content {
          key           = expressions.value["key"]
          member_type   = expressions.value["member_type"]
          operator      = expressions.value["operator"]
          resource_type = expressions.value["resource_type"]
          value         = expressions.value["value"]
        }
      }

      # For PathExpression
      dynamic "paths" {
        for_each = contains(keys(expression.value), "paths") ? expression.value["paths"] : []
        content {
          path = paths.value
        }
      }

      # For IPAddressExpression
      dynamic "ip_addresses" {
        for_each = contains(keys(expression.value), "ip_addresses") ? expression.value["ip_addresses"] : []
        content {
          ip_address = ip_addresses.value
        }
      }
    }
  }
}
