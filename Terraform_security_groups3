locals {
  sec_groups = yamldecode(file("${path.module}/input_test_file.yaml.txt"))["sec_groups"]
}

resource "nsxt_policy_group" "group" {
  for_each     = { for sg in local.sec_groups : sg.display_name => sg }
  display_name = each.value.display_name
  description  = try(each.value.id, null)
  domain       = "default"

  dynamic "criteria" {
    for_each = (
      length([
        for expr in each.value.expression :
          expr if try(expr.resource_type, "") == "NestedExpression"
      ]) > 1 ||
      contains([
        for expr in each.value.expression :
          try(expr.conjunction_operator, "")
      ], "OR")
    )
      ? [{
          type = "NestedExpressionGroup"
          exprs = [for expr in each.value.expression : expr if try(expr.resource_type, "") == "NestedExpression"]
        }]
      : [for expr in each.value.expression : expr]
    content {
      # Set conjunction only if type == NestedExpressionGroup
      lifecycle {
        ignore_changes = [conjunction]
      }

      # Use "OR" conjunction for grouped NestedExpressions, otherwise omit (default is OR)
      # Only include the attribute if needed to avoid Terraform syntax errors
      # Using this workaround as Terraform doesn't allow null attribute directly
      # Using a conditional block workaround below:
      dynamic "conjunction_block" {
        for_each = try(criteria.value.type, "") == "NestedExpressionGroup" ? [1] : []
        content {
          conjunction = "OR"
        }
      }

      # NestedExpressionGroup entries (AND conjunction inside)
      dynamic "criteria" {
        for_each = try(criteria.value.type, "") == "NestedExpressionGroup" ? criteria.value.exprs : []
        content {
          conjunction = "AND"
          dynamic "condition" {
            for_each = [for sub in criteria.value.expressions : sub if try(sub.resource_type, "") == "Condition"]
            content {
              key         = condition.value.key
              member_type = condition.value.member_type
              operator    = condition.value.operator
              value       = condition.value.value
            }
          }
        }
      }

      # Single NestedExpression
      dynamic "condition" {
        for_each = try(criteria.value.resource_type, "") == "NestedExpression"
          ? [for sub in criteria.value.expressions : sub if try(sub.resource_type, "") == "Condition"]
          : []
        content {
          key         = condition.value.key
          member_type = condition.value.member_type
          operator    = condition.value.operator
          value       = condition.value.value
        }
      }

      # Single Condition (flat tag)
      dynamic "condition" {
        for_each = try(criteria.value.resource_type, "") == "Condition" ? [criteria.value] : []
        content {
          key         = condition.value.key
          member_type = condition.value.member_type
          operator    = condition.value.operator
          value       = condition.value.value
        }
      }

      # IPAddressExpression
      dynamic "ipaddress_expression" {
        for_each = try(criteria.value.resource_type, "") == "IPAddressExpression" ? [criteria.value] : []
        content {
          ip_addresses = criteria.value.ip_addresses
        }
      }

      # PathExpression (Segments)
      dynamic "path_expression" {
        for_each = try(criteria.value.resource_type, "") == "PathExpression" ? [criteria.value] : []
        content {
          member_paths = criteria.value.paths
        }
      }
    }
  }
}
